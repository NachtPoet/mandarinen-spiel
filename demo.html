<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mandarinen Rhythmus-Spiel</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background-color: #000;
            color: #fff;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .game-container {
            position: relative;
            width: 800px;
            height: 600px;
            max-width: 95vw;
            max-height: 95vh;
            background-color: #111;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        
        /* Responsive styles */
        @media (max-width: 850px) {
            .game-container {
                width: 95vw;
                height: 95vh;
            }
        }

        .background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('https://mandarinenspiel.alexandrajanzen.de/assets/audio/stems/cover.jpg');
            background-size: cover;
            background-position: center;
            opacity: 0.3;
            filter: blur(3px);
        }

        .header {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 1;
        }

        .title {
            font-size: 28px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 18px;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        /* Mobile adjustments for header */
        @media (max-width: 767px) {
            .title {
                font-size: 20px;
            }
            
            .subtitle {
                font-size: 14px;
            }
        }
        
        @media (max-width: 480px) {
            .title {
                font-size: 18px;
            }
            
            .subtitle {
                font-size: 12px;
            }
        }

        .tracks-container {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 700px;
            display: flex;
            justify-content: space-between;
            z-index: 1;
        }

        .track {
            width: 100px;
            height: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        
        /* Mobile layout for tracks */
        @media (max-width: 767px) {
            .tracks-container {
                width: 90%;
                bottom: 150px;
            }
            
            .track {
                width: 18%;
                height: 250px;
            }
            
            .track-name {
                font-size: 12px;
            }
        }
        
        @media (max-width: 480px) {
            .tracks-container {
                bottom: 120px;
            }
            
            .track {
                height: 200px;
            }
        }

        .track-lane {
            width: 60px;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        .track-name {
            margin-bottom: 10px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        /* Mobile adjustments for track lanes */
        @media (max-width: 767px) {
            .track-lane {
                width: 90%;
            }
        }

        .hit-zone {
            position: absolute;
            bottom: 0;
            width: 60px;
            height: 60px;
            background-color: rgba(255, 215, 0, 0.3);
            border: 2px solid #FFD700;
            border-radius: 10px;
            z-index: 1;
        }
        
        /* Mobile adjustments for hit zones */
        @media (max-width: 767px) {
            .hit-zone {
                width: 90%;
                height: 50px;
                left: 50%;
                transform: translateX(-50%);
            }
        }

        .note {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: #FFD700;
            border-radius: 50%;
            left: 5px;
            transform: translateY(0);
            animation: fallDown linear;
        }

        @keyframes fallDown {
            0% {
                transform: translateY(-100%);
            }
            100% {
                transform: translateY(300px);
            }
        }
        
        /* Mobile adjustments for notes */
        @media (max-width: 767px) {
            .note {
                width: 40px;
                height: 40px;
                left: 50%;
                transform: translateX(-50%) translateY(0);
            }
            
            @keyframes fallDown {
                0% {
                    transform: translateX(-50%) translateY(-100%);
                }
                100% {
                    transform: translateX(-50%) translateY(250px);
                }
            }
        }
        
        @media (max-width: 480px) {
            .note {
                width: 35px;
                height: 35px;
            }
            
            @keyframes fallDown {
                0% {
                    transform: translateX(-50%) translateY(-100%);
                }
                100% {
                    transform: translateX(-50%) translateY(200px);
                }
            }
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 1;
        }

        .btn {
            padding: 10px 20px;
            margin: 0 10px;
            background-color: #FFD700;
            color: #000;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background-color: #FFC000;
            transform: scale(1.05);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .score-container {
            position: absolute;
            top: 80px;
            right: 20px;
            text-align: right;
            z-index: 1;
        }

        .score {
            font-size: 24px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .multiplier {
            font-size: 18px;
            color: #fff;
        }
        
        /* Mobile adjustments for score */
        @media (max-width: 767px) {
            .score-container {
                top: 60px;
                right: 10px;
            }
            
            .score {
                font-size: 18px;
            }
            
            .multiplier {
                font-size: 14px;
            }
        }

        .key-hint {
            position: absolute;
            bottom: 65px;
            width: 60px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            padding: 5px 0;
        }
        
        /* Mobile adjustments for key hints */
        @media (max-width: 767px) {
            .key-hint {
                display: none; /* Hide keyboard hints on mobile */
            }
        }
        
        /* Touch areas for mobile */
        .touch-area {
            display: none; /* Hidden by default, shown on mobile */
            position: absolute;
            bottom: 10px;
            width: 90%;
            height: 40px;
            background-color: rgba(255, 215, 0, 0.2);
            border: 2px solid #FFD700;
            border-radius: 10px;
            z-index: 2;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            line-height: 40px;
            font-weight: bold;
            color: #FFD700;
        }
        
        @media (max-width: 767px) {
            .touch-area {
                display: block;
            }
        }

        .hit-feedback {
            position: absolute;
            bottom: 0;
            width: 100%;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .perfect {
            color: #00FFFF;
        }

        .good {
            color: #00FF00;
        }

        .ok {
            color: #FFFF00;
        }

        .missed {
            color: #FF0000;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .modal-content {
            background-color: #111;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            border: 2px solid #FFD700;
        }
        
        /* Mobile adjustments for modals */
        @media (max-width: 767px) {
            .modal-content {
                padding: 20px;
            }
            
            .modal-title {
                font-size: 20px;
            }
            
            .modal-text {
                font-size: 14px;
            }
        }

        .modal-title {
            font-size: 24px;
            color: #FFD700;
            margin-bottom: 20px;
        }

        .modal-text {
            font-size: 16px;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .difficulty-buttons {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .difficulty-btn {
            padding: 10px 20px;
            margin: 0 10px;
            background-color: #333;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .difficulty-btn.selected {
            background-color: #FFD700;
            color: #000;
        }

        .active-instrument {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background-color: #00FF00;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .instrument-controls {
            position: absolute;
            top: 150px;
            right: 20px;
            display: flex;
            flex-direction: column;
            z-index: 1;
        }
        
        /* Mobile adjustments for instrument controls */
        @media (max-width: 767px) {
            .instrument-controls {
                top: 100px;
                right: 10px;
            }
            
            .toggle-label {
                font-size: 12px;
            }
        }
        
        @media (max-width: 480px) {
            .instrument-controls {
                top: 90px;
            }
        }

        .instrument-toggle {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .toggle-label {
            margin-right: 10px;
            color: #fff;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #333;
            transition: .4s;
            border-radius: 20px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #FFD700;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="background"></div>
        <div class="header">
            <div class="title">MANDARINEN - RHYTHMUS-SPIEL</div>
            <div class="subtitle">ALEXANDRA JANZEN</div>
        </div>

        <div class="score-container">
            <div class="score">Score: <span id="score-value">0</span></div>
            <div class="multiplier">Multiplikator: <span id="multiplier-value">x1</span></div>
        </div>

        <div class="instrument-controls">
            <div class="instrument-toggle">
                <span class="toggle-label">Vocals aktivieren</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="vocals-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>

        <div class="tracks-container">
            <div class="track">
                <div class="track-name">Piano</div>
                <div class="track-lane" id="track-piano">
                    <div class="hit-zone"></div>
                    <div class="key-hint">S</div>
                    <div class="touch-area">Tap</div>
                    <div class="active-instrument" id="active-piano"></div>
                </div>
                <div class="hit-feedback" id="feedback-piano"></div>
            </div>
            <div class="track">
                <div class="track-name">Bass/Drums</div>
                <div class="track-lane" id="track-drums">
                    <div class="hit-zone"></div>
                    <div class="key-hint">D</div>
                    <div class="touch-area">Tap</div>
                    <div class="active-instrument" id="active-drums"></div>
                </div>
                <div class="hit-feedback" id="feedback-drums"></div>
            </div>
            <div class="track">
                <div class="track-name">Gitarren</div>
                <div class="track-lane" id="track-guitars">
                    <div class="hit-zone"></div>
                    <div class="key-hint">F</div>
                    <div class="touch-area">Tap</div>
                    <div class="active-instrument" id="active-guitars"></div>
                </div>
                <div class="hit-feedback" id="feedback-guitars"></div>
            </div>
            <div class="track">
                <div class="track-name">Streicher</div>
                <div class="track-lane" id="track-strings">
                    <div class="hit-zone"></div>
                    <div class="key-hint">J</div>
                    <div class="touch-area">Tap</div>
                    <div class="active-instrument" id="active-strings"></div>
                </div>
                <div class="hit-feedback" id="feedback-strings"></div>
            </div>
            <div class="track">
                <div class="track-name">Synths/FX</div>
                <div class="track-lane" id="track-synths">
                    <div class="hit-zone"></div>
                    <div class="key-hint">K</div>
                    <div class="touch-area">Tap</div>
                    <div class="active-instrument" id="active-synths"></div>
                </div>
                <div class="hit-feedback" id="feedback-synths"></div>
            </div>
        </div>

        <div class="controls">
            <button class="btn" id="start-btn">Spiel starten</button>
            <button class="btn" id="restart-btn" style="display: none;">Neu starten</button>
        </div>
    </div>

    <div class="modal" id="start-modal">
        <div class="modal-content">
            <div class="modal-title">Mandarinen Rhythmus-Spiel</div>
            <div class="modal-text">
                Begleite Alexandra Janzen beim Song "Mandarinen"! Die Stimme l채uft automatisch, und du musst die Instrumente im richtigen Moment aktivieren.
                <br><br>
                Dr체cke die Tasten, wenn die Noten die Hit-Zone erreichen:
                <br>
                S = Piano, D = Bass/Drums, F = Gitarren, J = Streicher, K = Synths/FX
                <br><br>
                W채hle den Schwierigkeitsgrad:
            </div>
            <div class="difficulty-buttons">
                <button class="difficulty-btn" id="easy-btn">Leicht</button>
                <button class="difficulty-btn selected" id="medium-btn">Mittel</button>
                <button class="difficulty-btn" id="hard-btn">Schwer</button>
            </div>
            <button class="btn" id="modal-start-btn">Starten</button>
        </div>
    </div>

    <div class="modal" id="end-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-title">Spiel beendet!</div>
            <div class="modal-text">
                Dein Score: <span id="final-score">0</span>
                <br><br>
                <span id="performance-text"></span>
            </div>
            <button class="btn" id="modal-restart-btn">Erneut spielen</button>
        </div>
    </div>

    <script>
        // Audio analysis functions
        async function analyzeAudio() {
            const analyzeBtn = document.getElementById('analyze-btn');
            analyzeBtn.textContent = 'Analysiere...';
            analyzeBtn.disabled = true;
            
            // Create a temporary audio context for analysis
            const tempContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Load audio files again if needed
            const files = {
                piano: '01_piano.mp3',
                drums: '02R_bass_drums.mp3',
                guitars: '04_guitars.mp3',
                strings: '05_strings.mp3',
                synths: '06_synths_fx.mp3'
            };
            
            const baseUrl = 'https://mandarinenspiel.alexandrajanzen.de/assets/audio/stems/';
            
            // Create a status div to show progress
            const statusDiv = document.createElement('div');
            statusDiv.style.marginTop = '10px';
            statusDiv.style.color = '#FFD700';
            statusDiv.textContent = 'Analysiere Stems...';
            analyzeBtn.parentNode.insertBefore(statusDiv, analyzeBtn.nextSibling);
            
            try {
                // Initialize analyzed patterns
                analyzedPatterns = {
                    piano: [],
                    drums: [],
                    guitars: [],
                    strings: [],
                    synths: []
                };
                
                // Analyze each track
                for (const [track, file] of Object.entries(files)) {
                    statusDiv.textContent = `Analysiere ${track}...`;
                    
                    // Load the audio file
                    const response = await fetch(baseUrl + file);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await tempContext.decodeAudioData(arrayBuffer);
                    
                    // Analyze the track
                    const patterns = await analyzeTrack(tempContext, audioBuffer, track);
                    analyzedPatterns[track] = patterns;
                }
                
                statusDiv.textContent = 'Analyse abgeschlossen!';
                statusDiv.style.color = '#00FF00';
                
                // Enable the analyzed patterns toggle
                document.getElementById('analyze-toggle').disabled = false;
                
                // Enable analyze button again
                analyzeBtn.textContent = 'Erneut analysieren';
                analyzeBtn.disabled = false;
                
                // Auto-select the toggle
                document.getElementById('analyze-toggle').checked = true;
                useAnalyzedPatterns = true;
                
            } catch (error) {
                console.error('Error analyzing audio:', error);
                statusDiv.textContent = 'Fehler bei der Analyse!';
                statusDiv.style.color = '#FF0000';
                
                // Enable analyze button again
                analyzeBtn.textContent = 'Audio analysieren';
                analyzeBtn.disabled = false;
            } finally {
                // Close the temporary audio context
                if (tempContext.state !== 'closed') {
                    tempContext.close();
                }
            }
        }
        
        // Analyze a single track
        async function analyzeTrack(context, buffer, trackName) {
            // Create an offline audio context for analysis
            const offlineContext = new OfflineAudioContext(1, buffer.length, buffer.sampleRate);
            
            // Create source
            const source = offlineContext.createBufferSource();
            source.buffer = buffer;
            
            // Create analyzer
            const analyzer = offlineContext.createAnalyser();
            analyzer.fftSize = 2048;
            
            // Connect nodes
            source.connect(analyzer);
            analyzer.connect(offlineContext.destination);
            
            // Start the source
            source.start(0);
            
            // Process the audio
            const renderedBuffer = await offlineContext.startRendering();
            
            // Get the audio data
            const channelData = renderedBuffer.getChannelData(0);
            
            // Detect onsets (peaks in energy)
            const patterns = [];
            
            // Process parameters based on track type
            let energyThreshold, minDistance, noteLength;
            
            switch (trackName) {
                case 'drums':
                    energyThreshold = 0.02;
                    minDistance = 0.4; // seconds
                    noteLength = 4;
                    break;
                case 'piano':
                    energyThreshold = 0.01;
                    minDistance = 0.8;
                    noteLength = 8;
                    break;
                case 'guitars':
                    energyThreshold = 0.008;
                    minDistance = 2.0;
                    noteLength = 6;
                    break;
                case 'strings':
                    energyThreshold = 0.006;
                    minDistance = 3.0;
                    noteLength = 10;
                    break;
                case 'synths':
                    energyThreshold = 0.008;
                    minDistance = 2.5;
                    noteLength = 5;
                    break;
                default:
                    energyThreshold = 0.01;
                    minDistance = 1.0;
                    noteLength = 4;
            }
            
            // Calculate frame size for analysis (100ms windows)
            const frameSize = Math.floor(buffer.sampleRate * 0.1);
            let lastPeakTime = -minDistance;
            
            // Process frames
            for (let i = 0; i < channelData.length; i += frameSize) {
                // Calculate energy in this frame
                let energy = 0;
                for (let j = 0; j < frameSize && i + j < channelData.length; j++) {
                    energy += Math.abs(channelData[i + j]);
                }
                energy /= frameSize;
                
                // Calculate time in seconds
                const time = i / buffer.sampleRate;
                
                // Check if this is a peak
                if (energy > energyThreshold && time - lastPeakTime >= minDistance) {
                    // Add to patterns
                    patterns.push({
                        time: time,
                        duration: noteLength,
                        energy: energy
                    });
                    
                    lastPeakTime = time;
                }
            }
            
            // Limit to the top patterns based on energy
            patterns.sort((a, b) => b.energy - a.energy);
            
            // Max number of patterns based on track and difficulty
            let maxPatterns;
            switch (difficulty) {
                case 'easy':
                    maxPatterns = trackName === 'piano' || trackName === 'drums' ? 20 : 10;
                    break;
                case 'hard':
                    maxPatterns = trackName === 'piano' || trackName === 'drums' ? 40 : 25;
                    break;
                default: // medium
                    maxPatterns = trackName === 'piano' || trackName === 'drums' ? 30 : 15;
            }
            
            // Keep only the top patterns
            const topPatterns = patterns.slice(0, maxPatterns);
            
            // Sort by time
            topPatterns.sort((a, b) => a.time - b.time);
            
            // Ensure piano starts right at the beginning
            if (trackName === 'piano') {
                // Add a note at the very beginning if there isn't one already
                if (topPatterns.length > 0 && topPatterns[0].time > 1) {
                    topPatterns.unshift({
                        time: 0.5,
                        duration: noteLength,
                        energy: 0.05
                    });
                }
            }
            
            // Add some debug information
            console.log(`Track ${trackName} analysis complete. Found ${patterns.length} patterns, using ${topPatterns.length}`);
            console.log(`First few patterns:`, topPatterns.slice(0, 3));
            
            return topPatterns;
        }
        // Audio Context
        let audioContext;
        let gainNodes = {};
        let audioBuffers = {};
        let audioSources = {};
        let audioAnalysers = {};
        let audioDataArrays = {};
        let isPlaying = false;
        let startTime = 0;
        let analyzedPatterns = null;
        let useAnalyzedPatterns = false;

        // Game variables
        let score = 0;
        let multiplier = 1;
        let combo = 0;
        let difficulty = 'medium';
        let notePatterns = {};
        let activeNotes = [];
        let instrumentStates = {
            piano: false,
            drums: false,
            guitars: false,
            strings: false,
            synths: false,
            vocals: true
        };

        // DOM Elements
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const startModal = document.getElementById('start-modal');
        const endModal = document.getElementById('end-modal');
        const modalStartBtn = document.getElementById('modal-start-btn');
        const modalRestartBtn = document.getElementById('modal-restart-btn');
        const easyBtn = document.getElementById('easy-btn');
        const mediumBtn = document.getElementById('medium-btn');
        const hardBtn = document.getElementById('hard-btn');
        const vocalsToggle = document.getElementById('vocals-toggle');
        const scoreValue = document.getElementById('score-value');
        const multiplierValue = document.getElementById('multiplier-value');
        const finalScore = document.getElementById('final-score');
        const performanceText = document.getElementById('performance-text');

        // Track elements
        const tracks = ['piano', 'drums', 'guitars', 'strings', 'synths'];
        const trackElements = {};
        const activeInstrumentElements = {};
        const feedbackElements = {};

        tracks.forEach(track => {
            trackElements[track] = document.getElementById(`track-${track}`);
            activeInstrumentElements[track] = document.getElementById(`active-${track}`);
            feedbackElements[track] = document.getElementById(`feedback-${track}`);
        });

        // Key mappings
        const keyMap = {
            's': 'piano',
            'd': 'drums',
            'f': 'guitars',
            'j': 'strings',
            'k': 'synths'
        };

        // Note patterns based on song structure
        function generateNotePatterns() {
            const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Base patterns - now with more rhythmic structure and less overlap
            const basePatterns = {
                piano: [
                    { time: 2.0, duration: 8 },
                    { time: 10.0, duration: 8 },
                    { time: 22.0, duration: 8 },
                    { time: 34.0, duration: 8 },
                    { time: 46.0, duration: 8 },
                    { time: 58.0, duration: 8 },
                    { time: 70.0, duration: 8 },
                    { time: 82.0, duration: 8 },
                    { time: 94.0, duration: 8 },
                    { time: 106.0, duration: 8 },
                    { time: 118.0, duration: 8 },
                    { time: 130.0, duration: 8 },
                    { time: 142.0, duration: 8 },
                    { time: 154.0, duration: 8 }
                ],
                drums: [
                    { time: 6.0, duration: 4 },
                    { time: 14.0, duration: 4 },
                    { time: 26.0, duration: 4 },
                    { time: 38.0, duration: 4 },
                    { time: 50.0, duration: 4 },
                    { time: 62.0, duration: 4 },
                    { time: 74.0, duration: 4 },
                    { time: 86.0, duration: 4 },
                    { time: 98.0, duration: 4 },
                    { time: 110.0, duration: 4 },
                    { time: 122.0, duration: 4 },
                    { time: 134.0, duration: 4 },
                    { time: 146.0, duration: 4 },
                    { time: 158.0, duration: 4 }
                ],
                guitars: [
                    { time: 4.0, duration: 6 },
                    { time: 16.0, duration: 6 },
                    { time: 28.0, duration: 6 },
                    { time: 40.0, duration: 6 },
                    { time: 52.0, duration: 6 },
                    { time: 64.0, duration: 6 },
                    { time: 76.0, duration: 6 },
                    { time: 88.0, duration: 6 },
                    { time: 100.0, duration: 6 },
                    { time: 112.0, duration: 6 },
                    { time: 124.0, duration: 6 },
                    { time: 136.0, duration: 6 },
                    { time: 148.0, duration: 6 },
                    { time: 160.0, duration: 6 }
                ],
                strings: [
                    { time: 8.0, duration: 10 },
                    { time: 20.0, duration: 10 },
                    { time: 32.0, duration: 10 },
                    { time: 44.0, duration: 10 },
                    { time: 56.0, duration: 10 },
                    { time: 68.0, duration: 10 },
                    { time: 80.0, duration: 10 },
                    { time: 92.0, duration: 10 },
                    { time: 104.0, duration: 10 },
                    { time: 116.0, duration: 10 },
                    { time: 128.0, duration: 10 },
                    { time: 140.0, duration: 10 },
                    { time: 152.0, duration: 10 }
                ],
                synths: [
                    { time: 12.0, duration: 5 },
                    { time: 24.0, duration: 5 },
                    { time: 36.0, duration: 5 },
                    { time: 48.0, duration: 5 },
                    { time: 60.0, duration: 5 },
                    { time: 72.0, duration: 5 },
                    { time: 84.0, duration: 5 },
                    { time: 96.0, duration: 5 },
                    { time: 108.0, duration: 5 },
                    { time: 120.0, duration: 5 },
                    { time: 132.0, duration: 5 },
                    { time: 144.0, duration: 5 },
                    { time: 156.0, duration: 5 }
                ]
            };
            
            // Create mobile-friendly patterns (no overlapping notes)
            const mobileBasePatterns = {
                piano: [
                    { time: 2.0, duration: 8 },
                    { time: 18.0, duration: 8 },
                    { time: 34.0, duration: 8 },
                    { time: 50.0, duration: 8 },
                    { time: 66.0, duration: 8 },
                    { time: 82.0, duration: 8 },
                    { time: 98.0, duration: 8 },
                    { time: 114.0, duration: 8 },
                    { time: 130.0, duration: 8 },
                    { time: 146.0, duration: 8 }
                ],
                drums: [
                    { time: 6.0, duration: 4 },
                    { time: 22.0, duration: 4 },
                    { time: 38.0, duration: 4 },
                    { time: 54.0, duration: 4 },
                    { time: 70.0, duration: 4 },
                    { time: 86.0, duration: 4 },
                    { time: 102.0, duration: 4 },
                    { time: 118.0, duration: 4 },
                    { time: 134.0, duration: 4 },
                    { time: 150.0, duration: 4 }
                ],
                guitars: [
                    { time: 10.0, duration: 6 },
                    { time: 26.0, duration: 6 },
                    { time: 42.0, duration: 6 },
                    { time: 58.0, duration: 6 },
                    { time: 74.0, duration: 6 },
                    { time: 90.0, duration: 6 },
                    { time: 106.0, duration: 6 },
                    { time: 122.0, duration: 6 },
                    { time: 138.0, duration: 6 },
                    { time: 154.0, duration: 6 }
                ],
                strings: [
                    { time: 14.0, duration: 10 },
                    { time: 30.0, duration: 10 },
                    { time: 46.0, duration: 10 },
                    { time: 62.0, duration: 10 },
                    { time: 78.0, duration: 10 },
                    { time: 94.0, duration: 10 },
                    { time: 110.0, duration: 10 },
                    { time: 126.0, duration: 10 },
                    { time: 142.0, duration: 10 },
                    { time: 158.0, duration: 10 }
                ],
                synths: [
                    { time: 0.0, duration: 5 },
                    { time: 16.0, duration: 5 },
                    { time: 32.0, duration: 5 },
                    { time: 48.0, duration: 5 },
                    { time: 64.0, duration: 5 },
                    { time: 80.0, duration: 5 },
                    { time: 96.0, duration: 5 },
                    { time: 112.0, duration: 5 },
                    { time: 128.0, duration: 5 },
                    { time: 144.0, duration: 5 }
                ]
            };
            
            // Use mobile patterns if on mobile device
            let selectedPatterns = isMobileDevice ? mobileBasePatterns : basePatterns;
            
            // Adjust patterns based on difficulty
            notePatterns = JSON.parse(JSON.stringify(selectedPatterns));
            
            if (difficulty === 'easy') {
                // Fewer notes for easy mode and ensure they don't overlap
                for (const track in notePatterns) {
                    notePatterns[track] = notePatterns[track].filter((_, index) => index % 2 === 0);
                }
                
                // If on mobile, add extra spacing between notes regardless of difficulty
                if (isMobileDevice) {
                    const allTimes = [];
                    // Collect all times from all tracks
                    for (const track in notePatterns) {
                        notePatterns[track].forEach(note => allTimes.push(note.time));
                    }
                    
                    // Sort times
                    allTimes.sort((a, b) => a - b);
                    
                    // Check for notes that are too close together (less than 3 seconds apart)
                    for (let i = 1; i < allTimes.length; i++) {
                        if (allTimes[i] - allTimes[i-1] < 3) {
                            // Find this note in patterns and remove it
                            for (const track in notePatterns) {
                                notePatterns[track] = notePatterns[track].filter(note => note.time !== allTimes[i]);
                            }
                        }
                    }
                }
            } else if (difficulty === 'hard' && !isMobileDevice) {
                // More notes for hard mode, but only on desktop
                for (const track in notePatterns) {
                    const originalPattern = [...notePatterns[track]];
                    originalPattern.forEach(note => {
                        // Add additional notes 2 seconds after each original note
                        if (note.time + 2 < 165) { // Don't add notes beyond song length
                            notePatterns[track].push({ time: note.time + 2, duration: note.duration });
                        }
                    });
                    // Sort by time
                    notePatterns[track].sort((a, b) => a.time - b.time);
                }
            }
            
            // For mobile medium and hard, ensure no notes appear at the same time
            if (isMobileDevice && difficulty !== 'easy') {
                // Collect all notes from all tracks
                const allNotes = [];
                for (const track in notePatterns) {
                    notePatterns[track].forEach(note => {
                        allNotes.push({
                            track: track,
                            time: note.time,
                            duration: note.duration
                        });
                    });
                }
                
                // Sort by time
                allNotes.sort((a, b) => a.time - b.time);
                
                // Ensure minimum spacing between notes (1.5s for medium, 1s for hard)
                const minSpacing = difficulty === 'medium' ? 1.5 : 1;
                for (let i = 1; i < allNotes.length; i++) {
                    if (allNotes[i].time - allNotes[i-1].time < minSpacing) {
                        allNotes[i].time = allNotes[i-1].time + minSpacing;
                    }
                }
                
                // Update note patterns with adjusted times
                for (const track in notePatterns) {
                    notePatterns[track] = [];
                }
                
                allNotes.forEach(note => {
                    notePatterns[note.track].push({
                        time: note.time,
                        duration: note.duration
                    });
                });
            }
        }

        // Initialize audio context and load audio files
        async function initAudio() {
            // Create audio context
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create gain nodes for each track
            tracks.forEach(track => {
                gainNodes[track] = audioContext.createGain();
                gainNodes[track].gain.value = 0; // Start with volume at 0
                
                // Create analyzer nodes for each track
                audioAnalysers[track] = audioContext.createAnalyser();
                audioAnalysers[track].fftSize = 2048;
                const bufferLength = audioAnalysers[track].frequencyBinCount;
                audioDataArrays[track] = {
                    time: new Uint8Array(bufferLength),
                    freq: new Uint8Array(bufferLength)
                };
                
                // Connect gain node to analyzer and then to destination
                gainNodes[track].connect(audioAnalysers[track]);
                audioAnalysers[track].connect(audioContext.destination);
            });
            
            // Create gain node for vocals
            gainNodes.vocals = audioContext.createGain();
            gainNodes.vocals.gain.value = 1; // Vocals start playing
            
            // Create analyzer for vocals
            audioAnalysers.vocals = audioContext.createAnalyser();
            audioAnalysers.vocals.fftSize = 2048;
            const vocalBufferLength = audioAnalysers.vocals.frequencyBinCount;
            audioDataArrays.vocals = {
                time: new Uint8Array(vocalBufferLength),
                freq: new Uint8Array(vocalBufferLength)
            };
            
            gainNodes.vocals.connect(audioAnalysers.vocals);
            audioAnalysers.vocals.connect(audioContext.destination);

            // Load audio files
            const files = {
                piano: '01_piano.mp3',
                drums: '02R_bass_drums.mp3',
                guitars: '04_guitars.mp3',
                strings: '05_strings.mp3',
                synths: '06_synths_fx.mp3',
                vocals: '07_vocals.mp3'
            };

            const baseUrl = 'https://mandarinenspiel.alexandrajanzen.de/assets/audio/stems/';
            
            // Load all audio files
            for (const [key, file] of Object.entries(files)) {
                try {
                    const response = await fetch(baseUrl + file);
                    const arrayBuffer = await response.arrayBuffer();
                    audioBuffers[key] = await audioContext.decodeAudioData(arrayBuffer);
                } catch (error) {
                    console.error(`Error loading audio file ${file}:`, error);
                }
            }
            
            // Add a button to analyze audio in the start modal
            const difficultyButtons = document.querySelector('.difficulty-buttons');
            const analyzeButton = document.createElement('button');
            analyzeButton.textContent = 'Audio analysieren';
            analyzeButton.className = 'btn';
            analyzeButton.id = 'analyze-btn';
            analyzeButton.style.marginTop = '15px';
            analyzeButton.addEventListener('click', analyzeAudio);
            difficultyButtons.parentNode.insertBefore(analyzeButton, difficultyButtons.nextSibling);
            
            // Add a toggle for using analyzed patterns
            const analyzeToggleContainer = document.createElement('div');
            analyzeToggleContainer.style.marginTop = '15px';
            analyzeToggleContainer.style.display = 'flex';
            analyzeToggleContainer.style.alignItems = 'center';
            analyzeToggleContainer.style.justifyContent = 'center';
            
            const analyzeToggleLabel = document.createElement('span');
            analyzeToggleLabel.textContent = 'Analysierte Muster verwenden: ';
            analyzeToggleLabel.style.color = '#fff';
            analyzeToggleLabel.style.marginRight = '10px';
            
            const analyzeToggle = document.createElement('label');
            analyzeToggle.className = 'toggle-switch';
            
            const analyzeToggleInput = document.createElement('input');
            analyzeToggleInput.type = 'checkbox';
            analyzeToggleInput.id = 'analyze-toggle';
            analyzeToggleInput.addEventListener('change', (e) => {
                useAnalyzedPatterns = e.target.checked;
                if (useAnalyzedPatterns && !analyzedPatterns) {
                    alert('Bitte zuerst die Audio-Analyse durchf체hren!');
                    e.target.checked = false;
                    useAnalyzedPatterns = false;
                }
            });
            
            const analyzeToggleSlider = document.createElement('span');
            analyzeToggleSlider.className = 'toggle-slider';
            
            analyzeToggle.appendChild(analyzeToggleInput);
            analyzeToggle.appendChild(analyzeToggleSlider);
            
            analyzeToggleContainer.appendChild(analyzeToggleLabel);
            analyzeToggleContainer.appendChild(analyzeToggle);
            
            difficultyButtons.parentNode.insertBefore(analyzeToggleContainer, analyzeButton.nextSibling);
        }

        // Start playing audio
        function playAudio() {
            if (!audioContext || isPlaying) return;
            
            // Resume audio context if suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            startTime = audioContext.currentTime;
            isPlaying = true;
            
            // Create source nodes for each track
            for (const [key, buffer] of Object.entries(audioBuffers)) {
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(gainNodes[key]);
                source.start(0);
                audioSources[key] = source;
            }
            
            // Start generating notes
            generateNotes();
            
            // Debug info
            console.log("Audio playback started");
            console.log("Analyzed patterns available:", analyzedPatterns !== null);
            console.log("Using analyzed patterns:", useAnalyzedPatterns);
        }

        // Stop all audio
        function stopAudio() {
            if (!isPlaying) return;
            
            for (const key in audioSources) {
                if (audioSources[key]) {
                    audioSources[key].stop();
                    audioSources[key].disconnect();
                    audioSources[key] = null;
                }
            }
            
            isPlaying = false;
            
            // Stop visualization if active
            stopVisualization();
        }

        // Toggle instrument sound
        function toggleInstrument(track, active, duration = null) {
            if (!gainNodes[track] || !isPlaying) return;
            
            const gain = gainNodes[track].gain;
            const targetValue = active ? 1 : 0;
            
            // Smooth transition
            gain.cancelScheduledValues(audioContext.currentTime);
            gain.setValueAtTime(gain.value, audioContext.currentTime);
            gain.linearRampToValueAtTime(targetValue, audioContext.currentTime + 0.1);
            
            // Update visual state
            instrumentStates[track] = active;
            
            if (track !== 'vocals') {
                activeInstrumentElements[track].style.opacity = active ? 1 : 0;
            }
            
            // Don't auto-disable if no duration specified
            if (duration === null) {
                return;
            }
        }

        // Generate falling notes based on patterns
        function generateNotes() {
            // Choose which patterns to use
            const patternsToUse = useAnalyzedPatterns && analyzedPatterns ? analyzedPatterns : notePatterns;
            
            console.log("Generating notes using patterns:", useAnalyzedPatterns ? "analyzed" : "predefined");
            console.log("Patterns:", patternsToUse);
            
            for (const track in patternsToUse) {
                if (!patternsToUse[track] || patternsToUse[track].length === 0) continue;
                
                patternsToUse[track].forEach(noteInfo => {
                    setTimeout(() => {
                        if (!isPlaying) return;
                        createNote(track, noteInfo.duration);
                    }, noteInfo.time * 1000);
                });
            }
        }

        // Create a falling note
        function createNote(track, noteDuration) {
            if (!trackElements[track] || !isPlaying) return;
            
            const note = document.createElement('div');
            note.className = 'note';
            
            // Calculate animation duration based on difficulty
            let animationDuration;
            switch (difficulty) {
                case 'easy':
                    animationDuration = 3;
                    break;
                case 'hard':
                    animationDuration = 1.5;
                    break;
                default: // medium
                    animationDuration = 2;
            }
            
            note.style.animationDuration = `${animationDuration}s`;
            trackElements[track].appendChild(note);
            
            // Track the note for hit detection
            const noteObj = {
                element: note,
                track: track,
                duration: noteDuration,
                hit: false
            };
            
            activeNotes.push(noteObj);
            
            // Remove the note after animation completes
            setTimeout(() => {
                if (note.parentNode) {
                    note.parentNode.removeChild(note);
                }
                
                // If note wasn't hit, it was missed
                if (!noteObj.hit && isPlaying) {
                    showFeedback(track, 'missed');
                    resetCombo();
                    
                    // Turn off the instrument when a note is missed
                    toggleInstrument(track, false);
                }
                
                // Remove from active notes
                const index = activeNotes.indexOf(noteObj);
                if (index !== -1) {
                    activeNotes.splice(index, 1);
                }
            }, animationDuration * 1000);
        }

        // Handle key press
        function handleKeyPress(event) {
            if (!isPlaying) return;
            
            const key = event.key.toLowerCase();
            if (keyMap[key]) {
                const track = keyMap[key];
                checkNoteHit(track);
            }
        }

        // Check if a note was hit
        function checkNoteHit(track) {
            // Find notes for this track
            const trackNotes = activeNotes.filter(note => note.track === track && !note.hit);
            if (trackNotes.length === 0) return;
            
            // Get the note closest to the hit zone
            trackNotes.sort((a, b) => {
                const aRect = a.element.getBoundingClientRect();
                const bRect = b.element.getBoundingClientRect();
                const hitRect = trackElements[track].querySelector('.hit-zone').getBoundingClientRect();
                
                return Math.abs(aRect.bottom - hitRect.top) - Math.abs(bRect.bottom - hitRect.top);
            });
            
            const closestNote = trackNotes[0];
            const noteRect = closestNote.element.getBoundingClientRect();
            const hitRect = trackElements[track].querySelector('.hit-zone').getBoundingClientRect();
            
            const distance = Math.abs(noteRect.bottom - hitRect.top);
            const hitZoneHeight = hitRect.height;
            
            let hitQuality;
            if (distance < hitZoneHeight * 0.2) {
                hitQuality = 'perfect';
            } else if (distance < hitZoneHeight * 0.4) {
                hitQuality = 'good';
            } else if (distance < hitZoneHeight * 0.7) {
                hitQuality = 'ok';
            } else {
                // Too far from hit zone
                return;
            }
            
            // Mark as hit
            closestNote.hit = true;
            closestNote.element.style.backgroundColor = '#00FF00';
            
            // Toggle instrument on
            toggleInstrument(track, true);
            
            // Auto-disable after duration
            setTimeout(() => {
                toggleInstrument(track, false);
            }, closestNote.duration * 1000);
            
            // Show feedback and update score
            showFeedback(track, hitQuality);
            updateScore(hitQuality);
            
            // Remove note element
            setTimeout(() => {
                if (closestNote.element.parentNode) {
                    closestNote.element.parentNode.removeChild(closestNote.element);
                }
            }, 100);
        }

        // Update score based on hit quality
        function updateScore(hitQuality) {
            let points;
            switch (hitQuality) {
                case 'perfect':
                    points = 100;
                    combo += 1;
                    break;
                case 'good':
                    points = 50;
                    combo += 1;
                    break;
                case 'ok':
                    points = 25;
                    combo += 1;
                    break;
                default:
                    points = 0;
                    combo = 0;
            }
            
            // Update multiplier based on combo
            if (combo >= 30) {
                multiplier = 4;
            } else if (combo >= 20) {
                multiplier = 3;
            } else if (combo >= 10) {
                multiplier = 2;
            } else {
                multiplier = 1;
            }
            
            score += points * multiplier;
            
            // Update UI
            scoreValue.textContent = score;
            multiplierValue.textContent = `x${multiplier}`;
        }

        // Reset combo
        function resetCombo() {
            combo = 0;
            multiplier = 1;
            multiplierValue.textContent = `x${multiplier}`;
        }

        // Show feedback based on hit quality
        function showFeedback(track, quality) {
            const feedbackElement = feedbackElements[track];
            
            let text;
            switch (quality) {
                case 'perfect':
                    text = 'Perfect!';
                    break;
                case 'good':
                    text = 'Gut!';
                    break;
                case 'ok':
                    text = 'OK';
                    break;
                case 'missed':
                    text = 'Verpasst!';
                    break;
                default:
                    text = '';
            }
            
            feedbackElement.textContent = text;
            feedbackElement.className = `hit-feedback ${quality}`;
            feedbackElement.style.opacity = 1;
            
            // Vibrate on mobile devices for tactile feedback (if supported)
            if (navigator.vibrate && quality !== 'missed') {
                switch (quality) {
                    case 'perfect':
                        navigator.vibrate(100);
                        break;
                    case 'good':
                        navigator.vibrate(70);
                        break;
                    case 'ok':
                        navigator.vibrate(40);
                        break;
                }
            }
            
            setTimeout(() => {
                feedbackElement.style.opacity = 0;
            }, 500);
        }

        // Start the game
        function startGame() {
            // Generate note patterns based on difficulty
            if (!useAnalyzedPatterns || !analyzedPatterns) {
                generateNotePatterns();
            }
            
            // Reset game state
            score = 0;
            multiplier = 1;
            combo = 0;
            scoreValue.textContent = score;
            multiplierValue.textContent = `x${multiplier}`;
            
            // Hide start button, show restart button
            startBtn.style.display = 'none';
            restartBtn.style.display = 'inline-block';
            
            // Start audio
            playAudio();
            
            // Start visualization if needed
            if (useAnalyzedPatterns) {
                startVisualization();
            }
            
            // End game after song duration (adjust as needed)
            setTimeout(() => {
                endGame();
            }, 210000); // ~3:30 minutes to ensure full song playback
        }
        
        // Audio visualization
        let visualizationActive = false;
        let visualizationCanvas;
        let visualizationContext;
        
        // Start visualization
        function startVisualization() {
            if (visualizationActive) return;
            
            // Create canvas for visualization
            visualizationCanvas = document.createElement('canvas');
            visualizationCanvas.width = 300;
            visualizationCanvas.height = 100;
            visualizationCanvas.style.position = 'absolute';
            visualizationCanvas.style.bottom = '20px';
            visualizationCanvas.style.left = '50%';
            visualizationCanvas.style.transform = 'translateX(-50%)';
            visualizationCanvas.style.zIndex = '5';
            visualizationCanvas.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            visualizationCanvas.style.borderRadius = '5px';
            
            // Add canvas to game container
            document.querySelector('.game-container').appendChild(visualizationCanvas);
            
            visualizationContext = visualizationCanvas.getContext('2d');
            visualizationActive = true;
            
            // Start animation
            updateVisualization();
        }
        
        // Update visualization
        function updateVisualization() {
            if (!visualizationActive || !isPlaying) return;
            
            visualizationContext.clearRect(0, 0, visualizationCanvas.width, visualizationCanvas.height);
            
            // Draw time-domain data for each track
            const trackColors = {
                piano: '#FF6347',
                drums: '#4169E1',
                guitars: '#32CD32',
                strings: '#9370DB',
                synths: '#FFD700',
                vocals: '#FF69B4'
            };
            
            const trackY = {
                piano: 10,
                drums: 25,
                guitars: 40,
                strings: 55,
                synths: 70,
                vocals: 85
            };
            
            for (const track in audioAnalysers) {
                if (!audioAnalysers[track]) continue;
                
                // Get time domain data
                audioAnalysers[track].getByteTimeDomainData(audioDataArrays[track].time);
                
                // Draw waveform
                visualizationContext.lineWidth = 2;
                visualizationContext.strokeStyle = trackColors[track] || '#FFF';
                visualizationContext.beginPath();
                
                const sliceWidth = visualizationCanvas.width / audioDataArrays[track].time.length;
                let x = 0;
                
                for (let i = 0; i < audioDataArrays[track].time.length; i++) {
                    const v = audioDataArrays[track].time[i] / 128.0;
                    const y = trackY[track] + (v * 15 - 15);
                    
                    if (i === 0) {
                        visualizationContext.moveTo(x, y);
                    } else {
                        visualizationContext.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                visualizationContext.lineTo(visualizationCanvas.width, trackY[track]);
                visualizationContext.stroke();
                
                // Draw track label
                visualizationContext.font = '10px Arial';
                visualizationContext.fillStyle = trackColors[track] || '#FFF';
                visualizationContext.fillText(track, 5, trackY[track] + 3);
            }
            
            // Keep updating
            requestAnimationFrame(updateVisualization);
        }
        
        // Stop visualization
        function stopVisualization() {
            visualizationActive = false;
            if (visualizationCanvas && visualizationCanvas.parentNode) {
                visualizationCanvas.parentNode.removeChild(visualizationCanvas);
            }
        }

        // End the game
        function endGame() {
            stopAudio();
            
            // Update final score
            finalScore.textContent = score;
            
            // Set performance text
            let performanceMessage;
            if (score >= 10000) {
                performanceMessage = 'Fantastisch! Du bist ein Rhythmus-Profi!';
            } else if (score >= 5000) {
                performanceMessage = 'Sehr gut! Du hast ein gutes Rhythmusgef체hl!';
            } else if (score >= 2000) {
                performanceMessage = 'Nicht schlecht! Mit etwas bung wirst du noch besser!';
            } else {
                performanceMessage = 'Guter Versuch! be weiter und verbessere deinen Score!';
            }
            
            performanceText.textContent = performanceMessage;
            
            // Show end modal
            endModal.style.display = 'flex';
        }

        // Restart the game
        function restartGame() {
            stopAudio();
            
            // Clear all notes
            activeNotes.forEach(note => {
                if (note.element.parentNode) {
                    note.element.parentNode.removeChild(note.element);
                }
            });
            activeNotes = [];
            
            // Reset instrument states
            for (const track of tracks) {
                instrumentStates[track] = false;
                activeInstrumentElements[track].style.opacity = 0;
            }
            
            // Hide end modal
            endModal.style.display = 'none';
            
            // Start game again
            startGame();
        }

        // Detect mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Function to add touch events
        function setupTouchEvents() {
            tracks.forEach(track => {
                const touchArea = trackElements[track].querySelector('.touch-area');
                if (touchArea) {
                    touchArea.addEventListener('touchstart', (e) => {
                        e.preventDefault(); // Prevent default touch behavior
                        checkNoteHit(track);
                    });
                    
                    // Also add click event for testing on desktop
                    touchArea.addEventListener('click', () => {
                        checkNoteHit(track);
                    });
                }
            });
        }
        
        // Update the modal text for mobile devices
        function updateModalForMobile() {
            const modalText = document.querySelector('.modal-text');
            if (isMobile) {
                modalText.innerHTML = 
                    'Begleite Alexandra Janzen beim Song "Mandarinen"! Die Stimme l채uft automatisch, und du musst die Instrumente im Takt aktivieren.' +
                    '<br><br>' +
                    'Tippe auf die Fl채chen, wenn die Noten die Hit-Zone erreichen. Die Noten folgen einem echten Rhythmus-Muster.' +
                    '<br><br>' +
                    'W채hle den Schwierigkeitsgrad:';
            }
        }

        // Event listeners
        startBtn.addEventListener('click', () => {
            startModal.style.display = 'flex';
            updateModalForMobile();
        });

        modalStartBtn.addEventListener('click', () => {
            startModal.style.display = 'none';
            startGame();
            
            // Setup touch events if on mobile
            if (isMobile) {
                setupTouchEvents();
            }
        });

        restartBtn.addEventListener('click', restartGame);
        modalRestartBtn.addEventListener('click', restartGame);

        easyBtn.addEventListener('click', () => {
            difficulty = 'easy';
            easyBtn.classList.add('selected');
            mediumBtn.classList.remove('selected');
            hardBtn.classList.remove('selected');
        });

        mediumBtn.addEventListener('click', () => {
            difficulty = 'medium';
            easyBtn.classList.remove('selected');
            mediumBtn.classList.add('selected');
            hardBtn.classList.remove('selected');
        });

        hardBtn.addEventListener('click', () => {
            difficulty = 'hard';
            easyBtn.classList.remove('selected');
            mediumBtn.classList.remove('selected');
            hardBtn.classList.add('selected');
        });

        vocalsToggle.addEventListener('change', (e) => {
            toggleInstrument('vocals', e.target.checked);
        });

        document.addEventListener('keydown', handleKeyPress);
        
        // Setup touch events on load if on mobile
        if (isMobile) {
            window.addEventListener('load', () => {
                updateModalForMobile();
                setupTouchEvents();
            });
        }

        // Initialize audio on page load
        window.addEventListener('load', initAudio);

        // Handle window focus/blur
        window.addEventListener('blur', () => {
            // Pause game when window loses focus
            if (isPlaying) {
                stopAudio();
                
                // Show restart button
                startBtn.style.display = 'none';
                restartBtn.style.display = 'inline-block';
            }
        });
    </script>
</body>
</html>